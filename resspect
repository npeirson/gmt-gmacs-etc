Array.prototype.clone = () -> this.slice(0);

ResSpect = (new_spec, old_spec, spec_flux, spec_err) -> 
  spec_lhs = []
  spec_width = []
  filter_lhs = []
  filter_width = []
   
  spec_lhs[0] = old_spec[0] - (old_spec[1]-old_spec[0])/2
  
  spec_width[-1] = (old_spec[-1] - old_spec[-2])
  
  spec_lhs[1..0] = (old_spec[1..0] + old_spec[0..-1])/2
  
  spec_width[0..-1] = spec_lhs[1..0] - spec_lhs[0..-1]
  
  filter_lhs[0] = new_spec[0] - (new_spec[-1] - new_spec[0])/2
  
  filter_widths[-1] = (new_spec[-1] - new_spec[-2])
  
  filter_lhs[-1] = new_spec[-1] + (new_spec[-1] - new_spec[-2])/2
  
  filter_lhs[1..-1] = (new_spec[1..0] + new_spec[0..-1])/2
  
  filter_width[0..-1] = filter_lhs[1..-1] - filer_lhs[0..-2]
  
  if filter_lhs[0] < spec_lhs[0] or filter_lhs[-1] > spec_lhs[-1] then console.log("ResSpect: The new wavelengths specified must fall within the range of the old wavelength values.")
  
  resampled_flux = []
  if spec_err is not None then if spec_err.shape not spec_flux.shape then console.log("ResSpect: If specified, spec_err must be the same shape as spec_flux.") else resampled_flux_err = []
    
  start = 0
  stop = 0

  # loop here
  # while here
  start += 1
  # while here
  stop += 1

  if stop == start then resampled_flux[j] = spec_flux[j] and # I guess...
    if spec_errs is not None then resampled_flux_err[j] = spec_errs[start]
  else 
    start_factor = (spec_lhs[start+1] - filter_lhs[j])/(spec_lhs[start+1] - spec_lhs[start]) and
    end_factor = (filter_lhs[j+1] - spec_lhs[stop])/(spec_lhs[stop+1] - spec_lhs[stop]) and
    spec_widths[start] *= start_factor and
    spec_widths[stop] *= end_factor and
    resampled_flux[j] = (spec_widths[start...(stop+1)] * spec_flux[start...(stop+1)]) and
    samp_sum += resampled_flux[j]  
  


var ResSpect,
  splice = [].splice;

Array.prototype.clone = function() {
  return this.slice(0);
  };

ResSpect = function(new_spec, old_spec, spec_flux, spec_err) {
  var end_factor, filter_lhs, filter_width, ref, ref1, ref2, ref3, to_reduce, two_reduce, three_reduce, resampled_flux, resampled_flux_err, spec_lhs, spec_width, start, start_factor, stop;
  spec_lhs = [];
  spec_width = [];
  filter_lhs = [];
  filter_width = [];
  spec_lhs[0] = old_spec[0] - (old_spec[1] - old_spec[0]) / 2;
  spec_width[-1] = old_spec[-1] - old_spec[-2];
  splice.apply(spec_lhs, [1, 0].concat(ref = (old_spec.slice(1, 1) + old_spec.slice(0)) / 2)), ref;
  splice.apply(spec_width, [0, 0].concat(ref1 = spec_lhs.slice(1, 1) - spec_lhs.slice(0))), ref1;
  filter_lhs[0] = new_spec[0] - (new_spec[-1] - new_spec[0]) / 2;
  filter_widths[-1] = new_spec[-1] - new_spec[-2];
  filter_lhs[-1] = new_spec[-1] + (new_spec[-1] - new_spec[-2]) / 2;
  splice.apply(filter_lhs, [1, -1].concat(ref2 = (new_spec.slice(1, 1) + new_spec.slice(0)) / 2)), ref2;
  splice.apply(filter_width, [0, 0].concat(ref3 = filter_lhs.slice(1) - filer_lhs.slice(0, -1))), ref3;
  if (filter_lhs[0] < spec_lhs[0] || filter_lhs[-1] > spec_lhs[-1]) {
    console.log("ResSpect: The new wavelengths specified must fall within the range of the old wavelength values.");
    }
  resampled_flux = [];
  if (spec_err === !None) {
    if (spec_err.shape(!spec_flux.shape)) {
      console.log("ResSpect: If specified, spec_err must be the same shape as spec_flux.");
    } else {
      resampled_flux_err = [];
      }
  }
  start = 0;
  stop = 0;
  var j;
  for (j = 0; j < new_spec.length; j++) {
    while (spec_lhs[start+1] <= filter_lhs[j]) {
      start++;
      }
    while (spec_lhs[stop+1] <= filter_lhs[j+1]) {
      stop++;
      }
    if (stop === start) {
      resampled_flux[j] = spec_flux[j] && (spec_errs === !None ? resampled_flux_err[j] = spec_errs[start] : void 0);
    } else {
        // something here
        var thing1 = spec_width.slice(start, +(stop + 1) + 1 || 9e9);
        start_factor = (spec_lhs[start + 1] - filter_lhs[j]) / (spec_lhs[start + 1] - spec_lhs[start]) && (end_factor = (filter_lhs[j + 1] - spec_lhs[stop]) / (spec_lhs[stop + 1] - spec_lhs[stop]) && (spec_widths[start] *= start_factor && (spec_widths[stop] *= end_factor && (resampled_flux[j] = (spec_widths.slice(start, (stop + 1)) * spec_flux.slice(start, (stop + 1))) && (samp_sum += resampled_flux[j] && (!(isNaN(spec_err)) ? void 0 : void 0))))));
        to_reduce = Math.pow(thing1 * spec_err.slice(start, +(stop + 1) + 1 || 9e9), 2);
        two_reduce = (spec_width[start..(stop+1)]);
        three_reduce = Math.pow(thing1 * spec_flux.slice(start, +(stop + 1) + 1 || 9e9), 2);
        resampled_flux[j] = Math.sqrt(to_reduce.reduceRight((accumulator, currentValue) => accumulator.concat(currentValue)))/three_reduce.reduce((accumulator, currentValue) => accumulator.concat(currentValue));
        
        if (spec_err == !None) {
          resampled_flux_err[j] = Math.sqrt(to_reduce.reduceRight((accumulator, currentValue) => accumulator.concat(currentValue)))/two_reduce.reduce((accumulator, currentValue) => accumulator.concat(currentValue));
          }
        spec_width[start] /= start_factor;
        spec_width[stop] /= end_factor;
        }
      }
  if (spec_err == !None) {
    return resampled_flux, resampled_flux_err;
  } else {
    return resampled_flux;
    }
  };